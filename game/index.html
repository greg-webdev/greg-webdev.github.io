<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Parkour Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #e0f2f7; /* Lighter sky blue */ }
        canvas { display: block; }
        #game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #333; /* Darker text for readability */
            background-color: rgba(255, 255, 255, 0.7); /* Slightly transparent white */
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            font-size: 14px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15); /* More pronounced shadow */
            user-select: none; /* Prevent text selection */
            transition: all 0.3s ease-in-out; /* Smooth transition for sizing */
        }
        #game-info.collapsed {
            padding-bottom: 0;
            overflow: hidden;
            max-height: 40px; /* Adjust based on initial height of heading + arrow */
            box-shadow: none; /* Remove shadow when collapsed for cleaner look */
        }
        #game-info .controls-content {
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            max-height: 200px; /* A value larger than the max height of content */
            opacity: 1;
        }
        #game-info.collapsed .controls-content {
            max-height: 0;
            opacity: 0;
        }
        #toggle-controls {
            cursor: pointer;
            margin-left: 8px;
            font-size: 1em;
            display: inline-block;
            transition: transform 0.3s ease-in-out;
        }
        #game-info.collapsed #toggle-controls {
            transform: rotate(-90deg); /* Rotate arrow when collapsed */
        }
        #game-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 2.5em; /* Larger font */
            font-weight: bold;
            display: none; /* Hidden by default */
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.7); /* Brighter glow */
            border: 3px solid #ffcc00; /* Gold border */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* Text shadow for pop */
        }
        #hack-input-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
        }
        #hack-input-container input {
            background: none;
            border: none;
            outline: none;
            color: #333;
            font-size: 14px;
            width: 80px;
        }
        #hack-status {
            margin-left: 10px;
            font-size: 12px;
            font-weight: bold;
            color: #555;
        }
    </style>
</head>
<body>
    <div id="game-info">
        <h3>Controls: <span id="toggle-controls">&#9660;</span></h3> <!-- Downward arrow -->
        <div class="controls-content">
            <p>W: Forward</p>
            <p>A: Left</p>
            <p>S: Backward</p>
            <p>D: Right</p>
            <p>Space: Jump</p>
            <p>Scroll Wheel: Zoom Camera</p>
            <p>Right Click + Drag: Rotate View (when mouse not locked)</p>
            <p>Click Canvas: Lock Mouse for First-Person View</p>
            <p>ESC: Unlock Mouse</p>
        </div>
    </div>
    <div id="hack-input-container">
        <input type="text" id="hack-textbox" placeholder="Enter command...">
        <span id="hack-status">Noclip: OFF</span>
    </div>
    <div id="game-status"></div>

    <script>
        // --- Global Game Variables ---
        let scene, camera, renderer;
        let player; // Now a THREE.Group
        let playerVelocity = new THREE.Vector3(); // Now represents continuous velocity
        const playerSpeed = 28; // Max horizontal speed
        const accelerationRate = 0.1; // How quickly player accelerates to max speed (0.05 - 0.2 works well)
        const frictionRate = 0.75; // How quickly player decelerates (0.8 - 0.95, higher is less friction)
        const jumpStrength = 25; // Initial upward velocity on jump
        const gravity = -50; // Units per second squared
        let onGround = false;
        let lastUpdateTime = performance.now(); // Use performance.now() for better accuracy

        const platforms = []; // Array to store all platforms
        let currentLevel = 1; // Current game level

        // Input states
        let keys = {
            w: false, a: false, s: false, d: false, space: false, shift: false
        };

        // Camera control variables
        let isRightClickDown = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let cameraDistance = 15; // Initial distance from player
        let cameraAngleX = Math.PI / 6; // Initial vertical angle (30 degrees)
        let cameraAngleY = -Math.PI / 4; // Initial horizontal angle (-45 degrees)
        const minCameraDistance = 5;
        const maxCameraDistance = 30;

        // Player dimensions for collision calculation (based on the new Roblox-like model)
        const playerTotalHeight = 5; // Head (1) + Torso (2) + Legs (2)
        const playerHalfHeight = playerTotalHeight / 2; // 2.5

        // Player's horizontal extent is determined by the arms (0.75 width, positioned -1.125 and +1.125 from center)
        // Left arm extends from -1.125 - 0.75/2 = -1.5
        // Right arm extends to 1.125 + 0.75/2 = 1.5
        const playerMaxHorizontalDimension = 3.0; 
        const playerHalfWidth = playerMaxHorizontalDimension / 2; // 1.5

        // Player's depth extent is determined by the head (1.0 depth)
        const playerMaxDepthDimension = 1.0; 
        const playerHalfDepth = playerMaxDepthDimension / 2; // 0.5

        // Game UI elements
        const gameStatusDiv = document.getElementById('game-status');
        const gameInfoDiv = document.getElementById('game-info');
        const toggleControlsBtn = document.getElementById('toggle-controls');
        const hackTextbox = document.getElementById('hack-textbox');
        const hackStatusSpan = document.getElementById('hack-status');
        let noclipEnabled = false; // New variable for noclip mode

        // --- Level End Platforms ---
        let level1EndPlatform;
        let level2EndPlatform;
        let level3EndPlatform;
        let level4EndPlatform;
        let level5EndPlatform; // For "Game Complete" check

        // Player death state and scattered parts
        let isPlayerDead = false;
        let detachedParts = []; // Array to hold individual parts when they scatter
        let resetTimeoutId; // To manage the timeout for resetting the level after death

        // Global references for individual player body meshes (created once in init)
        let headMesh, torsoMesh, leftArmMesh, rightArmMesh, leftLegMesh, rightLegMesh;
        let ground; // Reference to the ground mesh

        // --- Initialization Function ---
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200); // Add a bit of fog for depth

            // Camera setup - Initialized after player is created below.
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // High DPI support
            renderer.shadowMap.enabled = true; // Enable shadow maps
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060); // Softer ambient light
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1); // Main light source (sun)
            sunLight.position.set(20, 50, 30); // Position the sun
            sunLight.castShadow = true; // Make it cast shadows
            scene.add(sunLight);

            // Configure shadow camera for directional light
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 150;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            // scene.add(new THREE.CameraHelper(sunLight.shadow.camera)); // Uncomment to visualize shadow camera

            // Player Group (container for body parts)
            player = new THREE.Group();

            // Create all player parts only ONCE in init
            // Head (Yellow) - Now round
            headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshLambertMaterial({ color: 0xFFD700 }));
            // Torso (Light Blue)
            torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 0.75), new THREE.MeshLambertMaterial({ color: 0x87CEEB }));
            // Left Arm (Yellow)
            leftArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.75, 2, 0.75), new THREE.MeshLambertMaterial({ color: 0xFFD700 }));
            // Right Arm (Yellow)
            rightArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.75, 2, 0.75), new THREE.MeshLambertMaterial({ color: 0xFFD700 }));
            // Left Leg (Green)
            leftLegMesh = new THREE.Mesh(new THREE.BoxGeometry(0.75, 2, 0.75), new THREE.MeshLambertMaterial({ color: 0x66bb6a }));
            // Right Leg (Green)
            rightLegMesh = new THREE.Mesh(new THREE.BoxGeometry(0.75, 2, 0.75), new THREE.MeshLambertMaterial({ color: 0x66bb6a }));

            // Set castShadow for all these parts
            [headMesh, torsoMesh, leftArmMesh, rightArmMesh, leftLegMesh, rightLegMesh].forEach(mesh => mesh.castShadow = true);

            // Add parts to player group in init and set their initial local positions
            player.add(headMesh, torsoMesh, leftArmMesh, rightArmMesh, leftLegMesh, rightLegMesh);
            headMesh.position.y = 2.0;
            torsoMesh.position.y = 0.5;
            leftArmMesh.position.set(-1.125, 0.5, 0);
            rightArmMesh.position.set(1.125, 0.5, 0);
            leftLegMesh.position.set(-0.375, -1.5, 0);
            rightLegMesh.position.set(0.375, -1.5, 0);
            
            // Set initial position of the entire player group (feet at Y=0 initially)
            // This will be overridden by createLevel(1) which spawns on the first platform
            player.position.set(0, playerHalfHeight, 0); 
            scene.add(player); // Add the player group to the scene

            // Set initial camera position relative to player AFTER player is created
            updateCameraPosition(); 

            // Create ground plane (the "killbrick") - placed well below starting platforms
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x66bb6a }); // Green ground
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.position.y = -50; // Set killbrick ground much lower
            ground.receiveShadow = true; // Ground receives shadows
            scene.add(ground);

            // Create initial platforms for Level 1 - this will also position the player
            createLevel(1);

            // Event Listeners
            renderer.domElement.addEventListener('contextmenu', (event) => event.preventDefault()); // Disable context menu
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            // Toggle controls menu visibility
            toggleControlsBtn.addEventListener('click', () => {
                gameInfoDiv.classList.toggle('collapsed');
            });

            // Hack textbox logic
            hackTextbox.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    const command = hackTextbox.value.toLowerCase().trim();
                    if (command === 'hack') {
                        noclipEnabled = !noclipEnabled; // Toggle noclip state
                        hackStatusSpan.style.color = noclipEnabled ? '#28a745' : '#dc3545'; // Green for ON, Red for OFF
                        hackStatusSpan.innerText = `Noclip: ${noclipEnabled ? 'ON' : 'OFF'}`;
                        showGameStatus(noclipEnabled ? "Noclip Enabled!" : "Noclip Disabled!");
                        hackTextbox.value = ''; // Clear textbox
                        playerVelocity.y = 0; // Reset vertical velocity when toggling noclip
                        onGround = !noclipEnabled; // If noclip is enabled, player is not on ground; if disabled, assume can land
                    } else {
                        showGameStatus("Unknown command.");
                        hackTextbox.value = '';
                    }
                }
            });


            // --- Pointer Lock API Setup ---
            // Request pointer lock when canvas is clicked
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });

            // Listen for pointer lock changes
            document.addEventListener('pointerlockchange', pointerLockChange, false);
            document.addEventListener('mozpointerlockchange', pointerLockChange, false); // For Firefox
            document.addEventListener('webkitpointerlockchange', pointerLockChange, false); // For Webkit
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            // Prevent game controls from activating when typing in the textbox
            if (document.activeElement === hackTextbox) {
                return;
            }

            switch (event.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': // Spacebar
                    if (!noclipEnabled && onGround) { // Only jump if not in noclip and on ground
                        playerVelocity.y = jumpStrength;
                        onGround = false; // Player is no longer on the ground once jump initiated
                    }
                    keys.space = true;
                    break;
                case 'shift': keys.shift = true; break; // For noclip down
            }
        }

        function onKeyUp(event) {
            // Prevent game controls from activating when typing in the textbox
            if (document.activeElement === hackTextbox) {
                return;
            }

            switch (event.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'shift': keys.shift = false;
                    // Reset vertical velocity when shift/space is released in noclip
                    if (noclipEnabled) playerVelocity.y = 0;
                    break;
            }
        }

        function onMouseWheel(event) {
            // Only zoom if mouse is NOT locked to avoid conflicting with potential first-person camera control schemes
            if (document.pointerLockElement !== renderer.domElement) {
                cameraDistance += event.deltaY * 0.05; // Adjust zoom sensitivity
                cameraDistance = Math.max(minCameraDistance, Math.min(maxCameraDistance, cameraDistance));
                updateCameraPosition();
            }
        }

        function onMouseDown(event) {
            if (event.button === 2 && document.pointerLockElement !== renderer.domElement) { // Right mouse button, only if not pointer locked
                isRightClickDown = true;
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) { // Right mouse button
                isRightClickDown = false;
            }
        }

        function onMouseMove(event) {
            const isPointerLocked = document.pointerLockElement === renderer.domElement;

            let deltaX = 0;
            let deltaY = 0;

            if (isPointerLocked) {
                // If pointer is locked, use movementX/Y for camera rotation
                deltaX = event.movementX;
                deltaY = event.movementY;
            } else if (isRightClickDown) {
                // If pointer is not locked, only rotate if right mouse button is down
                deltaX = event.clientX - previousMouseX;
                deltaY = event.clientY - previousMouseY;
            } else {
                // If not locked and not right-clicking, no camera movement
                return;
            }

            // Apply rotation based on deltas
            cameraAngleY += deltaX * 0.007; // Horizontal rotation sensitivity
            cameraAngleX -= deltaY * 0.007; // Vertical rotation sensitivity (non-inverted)

            cameraAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleX)); // Clamp vertical angle to prevent flipping

            // Only update previousMouseX/Y if not pointer locked,
            // as movementX/Y are relative deltas and previous coordinates are not needed for calculation
            if (!isPointerLocked) {
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            }

            updateCameraPosition();
        }

        function pointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                // Pointer was just locked
                showGameStatus("Mouse Locked! (Press ESC to unlock)");
                setTimeout(hideGameStatus, 2000); // Hide message after 2 seconds
            } else {
                // Pointer was just unlocked
                showGameStatus("Mouse Unlocked! (Click canvas to lock)");
                isRightClickDown = false; // Ensure right click state is reset
                setTimeout(hideGameStatus, 2000); // Hide message after 2 seconds
            }
        }


        // --- Game Logic Functions ---
        function createPlatform(x, y, z, width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y + height / 2, z); // Adjust y to be centered at given y
            platform.receiveShadow = true; // Platforms receive shadows
            platform.castShadow = true; // Platforms can cast shadows (if higher up)
            scene.add(platform);
            platforms.push(platform);
            return platform; // Return the created platform for specific checks (like end platform)
        }

        // Function to clear all existing platforms from the scene
        function clearPlatforms() {
            while (platforms.length > 0) {
                const platform = platforms.pop();
                scene.remove(platform);
                platform.geometry.dispose();
                platform.material.dispose();
            }
        }

        // --- Level Creation Functions ---
        function createLevel(levelNum) {
            clearTimeout(resetTimeoutId); // Clear any pending reset timeout
            
            // Clean up scattered parts from previous death animation if any
            for (const part of detachedParts) {
                scene.remove(part);
            }
            detachedParts = []; // Clear the array

            // Re-add all player parts to the player group and reset their local positions
            // This ensures the player group is complete and visible again.
            if (!player.children.includes(headMesh)) player.add(headMesh);
            if (!player.children.includes(torsoMesh)) player.add(torsoMesh);
            if (!player.children.includes(leftArmMesh)) player.add(leftArmMesh);
            if (!player.children.includes(rightArmMesh)) player.add(rightArmMesh);
            if (!player.children.includes(leftLegMesh)) player.add(leftLegMesh);
            if (!player.children.includes(rightLegMesh)) player.add(rightLegMesh);

            headMesh.position.y = 2.0;
            torsoMesh.position.y = 0.5;
            leftArmMesh.position.set(-1.125, 0.5, 0);
            rightArmMesh.position.set(1.125, 0.5, 0);
            leftLegMesh.position.set(-0.375, -1.5, 0);
            rightLegMesh.position.set(0.375, -1.5, 0);


            isPlayerDead = false; // Reset death state
            
            // Ensure the player group is added to the scene if it was removed (after death)
            if (!scene.children.includes(player)) {
                scene.add(player);
            }

            currentLevel = levelNum;
            // Spawn player on the first platform of the current level
            // The first platform is at (0, 0, 0) and has height 0.5. Its top surface is at Y=0.25.
            // Player's feet should be at Y=0.25. Player's feet are at player.position.y - playerHalfHeight.
            // So, player.position.y = 0.25 + playerHalfHeight = 0.25 + 2.5 = 2.75
            player.position.set(0, 0.25 + playerHalfHeight, 0); // Exact spawn on top of initial platform
            playerVelocity.set(0, 0, 0);
            onGround = true; // Player starts on ground for new level

            // If noclip was active, disable it on level change
            if (noclipEnabled) {
                noclipEnabled = false;
                hackStatusSpan.style.color = '#dc3545';
                hackStatusSpan.innerText = 'Noclip: OFF';
            }

            // Generate platforms for the chosen level
            switch(levelNum) {
                case 1:
                    showGameStatus("Level 1");
                    createLevel1Platforms();
                    break;
                case 2:
                    showGameStatus("Level 2!");
                    createLevel2Platforms();
                    break;
                case 3:
                    showGameStatus("Level 3!");
                    createLevel3Platforms();
                    break;
                case 4:
                    showGameStatus("Level 4!");
                    createLevel4Platforms();
                    break;
                case 5:
                    showGameStatus("Level 5!");
                    createLevel5Platforms();
                    break;
                default:
                    showGameStatus("Game Complete! You beat all levels!");
                    break;
            }
        }

        function createLevel1Platforms() {
            // Parameters: x, y, z, width, height, depth, color
            createPlatform(0, 0, 0, 8, 0.5, 8, 0x4CAF50); // Start platform (dark green)
            createPlatform(15, 0, 0, 5, 0.5, 5, 0xFF5722); // Red-orange platform
            createPlatform(25, 3, 10, 6, 0.5, 6, 0x2196F3); // Blue platform, higher
            createPlatform(35, 0, -10, 7, 0.5, 7, 0xFFEB3B); // Yellow platform
            createPlatform(45, 6, 0, 3, 0.5, 3, 0x9C27B0); // Purple platform, small and high
            createPlatform(55, 2, 15, 4, 0.5, 4, 0x00BCD4); // Cyan platform
            createPlatform(65, 8, -5, 2, 0.5, 2, 0xFF9800); // Orange platform, tiny
            level1EndPlatform = createPlatform(75, 0, 0, 10, 0.5, 10, 0x795548); // Brownish end platform for Level 1
        }

        function createLevel2Platforms() {
            // Harder platforms: smaller, higher, more spread out
            createPlatform(0, 0, 0, 5, 0.5, 5, 0x66bb6a); // Start platform for Level 2
            createPlatform(10, 4, 0, 3, 0.5, 3, 0xF44336); // Red, higher jump
            createPlatform(18, 8, 5, 2, 0.5, 2, 0x4CAF50); // Green, smaller, more precise
            createPlatform(25, 12, -5, 3, 0.5, 3, 0xFFEB3B); // Yellow, high and far
            createPlatform(30, 15, 0, 2, 0.5, 2, 0x9C27B0); // Purple, very high and small
            createPlatform(38, 18, 8, 1, 0.5, 1, 0x2196F3); // Blue, very small, tricky
            level2EndPlatform = createPlatform(45, 20, -10, 4, 0.5, 4, 0xFF5722); // Orange, end platform for Level 2
        }

        function createLevel3Platforms() {
            // More verticality, smaller platforms, some gaps requiring precision
            createPlatform(0, 0, 0, 6, 0.5, 6, 0xADD8E6); // Light blue start
            createPlatform(8, 5, 0, 4, 0.5, 4, 0x87CEEB); // Sky blue
            createPlatform(15, 10, 5, 3, 0.5, 3, 0x4682B4); // Steel blue
            createPlatform(20, 15, -5, 2, 0.5, 2, 0x1E90FF); // Dodger blue
            createPlatform(22, 20, 0, 2, 0.5, 2, 0x6A5ACD); // Slate blue
            createPlatform(25, 25, 8, 1.5, 0.5, 1.5, 0x483D8B); // Dark slate blue
            createPlatform(30, 28, 15, 1, 0.5, 1, 0x7B68EE); // Medium slate blue
            level3EndPlatform = createPlatform(38, 30, 0, 5, 0.5, 5, 0xBA55D3); // Medium purple end platform for Level 3
        }

        function createLevel4Platforms() {
            // Introducing more spaced out, smaller jumps, and potentially moving platforms (conceptually, not implemented as moving here)
            createPlatform(0, 0, 0, 7, 0.5, 7, 0xFFD700); // Gold start
            createPlatform(12, 0, 0, 2, 0.5, 2, 0xFFC107); // Amber, small jump
            createPlatform(18, 4, 5, 2, 0.5, 2, 0xFF9800); // Orange, higher
            createPlatform(22, 8, -5, 1.5, 0.5, 1.5, 0xF44336); // Red, even smaller
            createPlatform(25, 12, 0, 1.5, 0.5, 1.5, 0xE91E63); // Pink
            createPlatform(28, 16, 8, 1, 0.5, 1, 0x9C27B0); // Purple, very small
            createPlatform(30, 18, 15, 0.8, 0.5, 0.8, 0x673AB7); // Deep purple, tiny
            level4EndPlatform = createPlatform(35, 20, 0, 4, 0.5, 4, 0x2196F3); // Blue end platform for Level 4
        }

        function createLevel5Platforms() {
            // Ultimate challenge: very small platforms, large gaps, requires full jump strength and speed
            createPlatform(0, 0, 0, 5, 0.5, 5, 0x00FFFF); // Cyan start
            createPlatform(10, 5, 0, 1.5, 0.5, 1.5, 0x00BCD4); // Teal, high and small
            createPlatform(15, 10, 8, 1, 0.5, 1, 0x009688); // Dark teal, very small
            createPlatform(18, 15, -8, 0.8, 0.5, 0.8, 0x4CAF50); // Green, super tiny, far
            createPlatform(20, 20, 0, 0.7, 0.5, 0.7, 0x8BC34A); // Light green, even smaller
            createPlatform(22, 25, 10, 0.6, 0.5, 0.6, 0xCDDC39); // Lime green, extremely small
            createPlatform(24, 30, -10, 0.5, 0.5, 0.5, 0xFFEB3B); // Yellow, minimal
            level5EndPlatform = createPlatform(28, 35, 0, 3, 0.5, 3, 0xFF4500); // OrangeRed, final platform for Level 5
        }


        function updateCameraPosition() {
            // The player's group's origin is now at its center, so lookAt the player's position directly.
            // Adjust camera.position to orbit around player's center.
            const polarAngle = cameraAngleX; // Phi (vertical angle)
            const azimuthalAngle = cameraAngleY; // Theta (horizontal angle)

            const offsetX = cameraDistance * Math.sin(polarAngle) * Math.cos(azimuthalAngle);
            const offsetZ = cameraDistance * Math.sin(polarAngle) * Math.sin(azimuthalAngle);
            const offsetY = cameraDistance * Math.cos(polarAngle);

            camera.position.set(
                player.position.x + offsetX,
                player.position.y + offsetY,
                player.position.z + offsetZ
            );
            camera.lookAt(player.position); // Camera looks at the center of the player group
        }

        // --- Core Game Loop ---
        function update() {
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastUpdateTime) / 1000; // Delta time in seconds
            lastUpdateTime = currentTime;

            // --- Handle player death and scattering ---
            if (isPlayerDead) {
                // Update scattered parts
                for (let i = detachedParts.length - 1; i >= 0; i--) {
                    const part = detachedParts[i];
                    if (part.userData.velocity) {
                        part.userData.velocity.y += gravity * deltaTime; // Apply gravity
                        part.position.add(part.userData.velocity.clone().multiplyScalar(deltaTime));
                        part.rotation.x += part.userData.angularVelocity.x * deltaTime;
                        part.rotation.y += part.userData.angularVelocity.y * deltaTime;
                        part.rotation.z += part.userData.angularVelocity.z * deltaTime;

                        // Remove part if it falls too far
                        if (part.position.y < ground.position.y - 10) { // Remove if below killbrick + offset
                            scene.remove(part);
                            detachedParts.splice(i, 1);
                        }
                    }
                }
                return; // Don't process player movement if dead
            }

            // --- Player Movement (Horizontal) ---
            let targetMoveDirection = new THREE.Vector3();
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection); // Get direction camera is facing
            cameraDirection.y = 0; // Only consider horizontal component
            cameraDirection.normalize();

            const rightDirection = new THREE.Vector3().crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();

            if (keys.w) targetMoveDirection.add(cameraDirection);
            if (keys.s) targetMoveDirection.sub(cameraDirection);
            if (keys.a) targetMoveDirection.sub(rightDirection);
            if (keys.d) targetMoveDirection.add(rightDirection);

            // Normalize target direction if input is present
            if (targetMoveDirection.lengthSq() > 0) {
                targetMoveDirection.normalize().multiplyScalar(playerSpeed); // Target vector at max speed
                // Linearly interpolate playerVelocity towards the targetMoveDirection
                playerVelocity.x = THREE.MathUtils.lerp(playerVelocity.x, targetMoveDirection.x, accelerationRate);
                playerVelocity.z = THREE.MathUtils.lerp(playerVelocity.z, targetMoveDirection.z, accelerationRate);
            } else {
                // Apply friction if no input
                playerVelocity.x *= frictionRate;
                playerVelocity.z *= frictionRate;
                // Stop completely if velocity is very low
                if (Math.abs(playerVelocity.x) < 0.1) playerVelocity.x = 0;
                if (Math.abs(playerVelocity.z) < 0.1) playerVelocity.z = 0;
            }


            // --- Apply vertical movement (gravity or noclip) ---
            if (noclipEnabled) {
                playerVelocity.y = 0; // Reset vertical velocity for direct control
                const noclipVerticalSpeed = playerSpeed; // Use playerSpeed for noclip vertical
                if (keys.space) {
                    playerVelocity.y = noclipVerticalSpeed; // Move up with space
                } else if (keys.shift) {
                    playerVelocity.y = -noclipVerticalSpeed; // Move down with shift
                }
                onGround = false; // Always considered airborne in noclip
            } else {
                playerVelocity.y += gravity * deltaTime; // Apply gravity normally
            }
            
            // Store proposed next position
            const proposedPosition = player.position.clone().add(playerVelocity.clone().multiplyScalar(deltaTime));

            // --- Collision Detection for Player Bounding Box ---
            let newOnGround = false;
            // Create player bounding box at proposed position
            const playerMin = new THREE.Vector3(
                proposedPosition.x - playerHalfWidth,
                proposedPosition.y - playerHalfHeight,
                proposedPosition.z - playerHalfDepth
            );
            const playerMax = new THREE.Vector3(
                proposedPosition.x + playerHalfWidth,
                proposedPosition.y + playerHalfHeight,
                proposedPosition.z + playerHalfDepth
            );

            const playerBBox = new THREE.Box3(playerMin, playerMax);

            // --- Killbrick Ground Check ---
            // Only perform killbrick check if not in noclip
            if (!noclipEnabled) {
                const groundBBox = new THREE.Box3().setFromObject(ground); // Get ground's bounding box
                if (playerBBox.intersectsBox(groundBBox)) {
                    if (!isPlayerDead) { // Ensure death logic only runs once
                        handlePlayerDeath();
                    }
                    return; // Stop update cycle for this frame (player is dead)
                }
            }

            // --- Fall Detection (if falling off platforms into the void, *below* the killbrick ground itself) ---
            // This is a backup for when the player falls so far they are below the killbrick too.
            // Also only applies if not in noclip mode.
            if (!noclipEnabled && player.position.y < ground.position.y - 10) { // If player falls 10 units below the killbrick
                if (!isPlayerDead) {
                    handlePlayerDeath();
                }
                return; // Stop update cycle
            }


            // --- Regular Platform Collision Detection and Resolution ---
            // Only apply regular collision if not in noclip mode and not already dead (or handled death)
            if (!noclipEnabled && !isPlayerDead) {
                for (const platform of platforms) {
                    const platformBBox = new THREE.Box3().setFromObject(platform);

                    // If player is intersecting with the platform
                    if (playerBBox.intersectsBox(platformBBox)) {
                        // Level transition checks
                        if (currentLevel === 1 && platform === level1EndPlatform) {
                            createLevel(2);
                            return; // Stop current update cycle, new level initiated
                        } else if (currentLevel === 2 && platform === level2EndPlatform) {
                            createLevel(3);
                            return;
                        } else if (currentLevel === 3 && platform === level3EndPlatform) {
                            createLevel(4);
                            return;
                        } else if (currentLevel === 4 && platform === level4EndPlatform) {
                            createLevel(5);
                            return;
                        } else if (currentLevel === 5 && platform === level5EndPlatform) {
                            showGameStatus("Game Complete! You've mastered all levels!");
                            return;
                        }

                        // Determine overlap on each axis
                        const overlapX = Math.max(0, Math.min(playerMax.x, platformBBox.max.x) - Math.max(playerMin.x, platformBBox.min.x));
                        const overlapY = Math.max(0, Math.min(playerMax.y, platformBBox.max.y) - Math.max(playerMin.y, platformBBox.min.y));
                        const overlapZ = Math.max(0, Math.min(playerMax.z, platformBBox.max.z) - Math.max(playerMin.z, platformBBox.min.z));

                        // Resolve collision on the axis with the smallest overlap
                        if (overlapX < overlapY && overlapX < overlapZ) {
                            // Resolve X axis
                            if (proposedPosition.x < platform.position.x) { // Player is to the left of platform
                                proposedPosition.x -= overlapX;
                            } else { // Player is to the right
                                proposedPosition.x += overlapX;
                            }
                        } else if (overlapY < overlapX && overlapY < overlapZ) {
                            // Resolve Y axis (vertical collision)
                            // Collision from below (player falling onto platform)
                            if (playerVelocity.y < 0 && proposedPosition.y - playerHalfHeight < platformBBox.max.y && player.position.y - playerHalfHeight >= platformBBox.max.y) {
                                proposedPosition.y = platformBBox.max.y + playerHalfHeight;
                                playerVelocity.y = 0; // Stop vertical movement
                                newOnGround = true; // Player is now on the ground
                            } 
                            // Collision from above (player jumping into bottom of platform)
                            else if (playerVelocity.y > 0 && proposedPosition.y + playerHalfHeight > platformBBox.min.y && player.position.y + playerHalfHeight <= platformBBox.min.y) {
                                proposedPosition.y = platformBBox.min.y - playerHalfHeight;
                                playerVelocity.y = 0; // Stop vertical movement
                            }
                        } else {
                            // Resolve Z axis
                            if (proposedPosition.z < platform.position.z) { // Player is in front of platform
                                proposedPosition.z -= overlapZ;
                            } else { // Player is behind
                                proposedPosition.z += overlapZ;
                            }
                        }
                    }
                }
            }

            // Update player's position after all collision resolutions
            player.position.copy(proposedPosition);
            
            // Only update onGround if not in noclip mode
            if (!noclipEnabled) {
                onGround = newOnGround; 
            } else {
                onGround = false; // In noclip, player is never on ground
            }

            // Update camera position
            updateCameraPosition();
        }

        // --- Player Death Handling ---
        function handlePlayerDeath() {
            showGameStatus("You Died!");
            isPlayerDead = true;

            // Get current world position of each part before they are detached
            const partsAndWorldPositions = [];
            [headMesh, torsoMesh, leftArmMesh, rightArmMesh, leftLegMesh, rightLegMesh].forEach(part => {
                part.updateMatrixWorld(true); // Ensure world matrix is up-to-date for worldPosition
                const worldPosition = new THREE.Vector3();
                part.getWorldPosition(worldPosition);
                partsAndWorldPositions.push({ part, worldPosition });
            });

            // Remove the player group from the scene (which also removes its children from scene)
            scene.remove(player);

            // Re-add individual parts to the scene at their world positions, then apply scattering
            for (const { part, worldPosition } of partsAndWorldPositions) {
                // Ensure part is no longer a child of the player group before re-adding to scene
                // (It should already be removed by scene.remove(player) and player.remove(part) in previous iterations)
                // However, to be fully robust:
                if (part.parent) { // If it has a parent
                    part.parent.remove(part); // Remove from its current parent
                }
                scene.add(part);
                part.position.copy(worldPosition); // Set its position to its world position at time of detachment

                // Apply scattering physics properties
                part.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 20, // Random horizontal velocity
                    Math.random() * 15 + 10, // Upward kick (makes them fly up)
                    (Math.random() - 0.5) * 20
                );
                part.userData.angularVelocity = new THREE.Euler(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                detachedParts.push(part);
            }
            
            clearTimeout(resetTimeoutId);
            resetTimeoutId = setTimeout(() => {
                createLevel(currentLevel); // Reset to current level after death animation
            }, 3000); // 3 seconds delay for scattering effect
        }

        // --- UI Functions ---
        function showGameStatus(message) {
            gameStatusDiv.innerText = message;
            gameStatusDiv.style.display = 'block';
            gameStatusDiv.style.opacity = 1;
            gameStatusDiv.style.transition = 'opacity 0.3s ease-in-out';
            // For level messages, make it last a bit longer
            if (message.includes("Level") || message.includes("Game Complete") || message.includes("Noclip") || message.includes("Died")) {
                 setTimeout(() => {
                     gameStatusDiv.style.opacity = 0;
                     setTimeout(() => gameStatusDiv.style.display = 'none', 300);
                 }, 2000); // Show for 2 seconds
            }
        }

        function hideGameStatus() {
            gameStatusDiv.style.display = 'none';
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            update(); // Call update logic
            renderer.render(scene, camera); // Render the scene
        }

        // --- Start the game ---
        window.onload = function () {
            init(); // Initialize scene
            animate(); // Start animation loop
        };
    </script>
</body>
</html>
